# 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는
# 방법임

# 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록함

# 한번 해결한 문제는 다시 해결하지 않는다는 점에서 완전탐색을 이용했을때 
# 매우 비효율적인 시간복잡도를 가지는 문제라도 하더라도 다이나믹 프로그래밍을 이용해서
# 시간복잡도를 획기적으로 줄일수 있는 경우가 많음

# 다이나믹 프로그래밍의 구현은 일반적으로 두가지 방식(탑다운(하향식)과 보텀업(상향식))
# 으로 구성됨 

# 다이나믹 프로그래밍은 동적 계획법 이라고도 불림

# 일반적인 프로그래밍에서의 동적(Dynamic) 이란 자료구조에서 동적할당(Dynamic Allocation)은
# 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법을 의미함

# 반면에 다이나믹 프로그래밍에서 다이나믹은 별다른 의미 없이 사용된 단어임


# 다이나믹 프로그래밍의 조건

# 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있음
# 1. 최적 부분구조(Optimal Substructure)
# 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할수 있음
# 2. 중복되는 부분문제 (Overlapping Subproblem)
# 동일한 작은 문제를 반복적으로 해결해야함

# 피보나치 수열
# 피보나치 수열 담으과 같은 형태의 수열이며 다이나믹 프로그래밍으로 효과적으로 계산할
# 수 있음
# 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

# 점화식이란 인접한 항들 사이의 관계식을 의미함
# 피보나치 수열의 점화식으로 표현하면 다음과 같음

# An = An-1 + An-2, A1= 1 A2 = 1

def fibo(n):
    # 첫번째 or 두번째 피보나치수를 호출 했을때 종료 
    if n == 1 or n == 2:
        return 1
    # 그렇지 않다면 바로 앞쪽에 있는 피보나치수와 두칸앞에 있는 피보나치수를 더한
    # 값이 현재 피보나치수가 될수 있도록 만들어줌 
    return fibo(n - 1) + fibo(n - 2)

print(fibo(4))

# 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됨
#  => n의 값이 조금만 커져도 기하급수적으로 커짐
# 다음과 같이 f(2)가 여러 번 출 되는 것을 확인할 수 있음( 중복되는 부분 문제)

#                 f(6)

#         f(5)                    f(4)

#   f(4)            f(3)      f(3)    f(2)

# f(3)  f(2)      f(2)  f(1) f(2) f(1)

#f(2)f(1)
# f(2)가 5번 호출됨 -> 이미 해결된 답이 있으면 기록 해놔야함 -> 그렇지 않으면
# 중복된 문제를 계속 해결해야해서 비효율적임
# O(2^N) => f(30)을 계산하기 위해 약 10억가량의 연산을 수행해야함
# f(100)을 계산하려면 엄청 오래걸림
