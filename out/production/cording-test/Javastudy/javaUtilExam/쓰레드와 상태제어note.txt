쓰레드 3개가 있다면 jvm은 시간을 잘게 쪼갠 후에 한번은 쓰레드1을
또한번은 쓰레드 1을 또한번을 쓰레드2를 또한번은 쓰레드 3을
실행하게됨 -> 이것을 빠르게 실행하다 보니 쓰레드가 모두 동작하는
것 처럼 보임

이말은 쓰레드는 실행되었다가 멈췄다가 하는것을 반복한다고 말할수있음
그런데 멈췄다고 해서 아주 멈춘것은 아니고 실행대기 상태라고 말할수있음
쓰레드가 있고 해당 쓰레드를 new로 생성한후 start메소드를 실행하게 되면
쓰레드는 실행됨

이때 실행가능한 상태인 Runnable과 실행상태인 Running상태를 왔다갔다함
쓰레드를 실행하면 어떤 상태가 되냐 하면 Runnable상태와 Running상태가
된다가 말하면됨

실행되는 쓰레드 안에서 Thread.sleep메소드나 오브젝트가 가지고있는 wait메소드가
호출이 되면 쓰레드는 블락상태가 됨
쓰레드의 suspend메소드가 호출되도 블락됨 but suspend 메소드는 deprecated
되었기 때문에 사용하지 않는게 좋음

또한 쓰레드를 종료시킬 목적으로 만들어진 stop메소드도 버그가 있어 deprecated 되었고
resume메소드도 deprecated되었음 
Thread.sleep메소드는 특정시간이 지나면 자신 스스로 블락상태에서 빠져나와 Runnable이나
Running상태가 됨 

Object가 가지고 있는 wait메소드는 다른 쓰레드가 notify메소드나 notifyall이라는 메소드를
호출하기 전에는 블락 상태에서 빠져나올 수 없음

또한 wait메소드는 호출이 되면 모니터링락을 놓게됨
그래서 대기중인 다른 메소드가 실행되게 되게 됨 
쓰레드가 공유 객체의 sychronized 블록이나 메소드가 실행 되었는데 이미 다른 쓰레드가 모니터링락을
획득한 상태라면 라굴에서 블락된 상태가 되게 됨 -> 이역시 보통은 블락되었다 라고 말할수 있음

Thread의 Run메소드가 종료되면 쓰레드는 종료됨 -> 즉 Dead상태가 됨
쓰레드의 yield메소드가 호출되면 해당 쓰레드는 다른 쓰레드에게 자원을 양보하게 됨
즉 다른쓰레드가 좀더 빠르게 실행되게 할 수 있음

쓰레드가 가지고 있는 join메소드를 호출하게 되면 해당 쓰레드가 종료 될 때까지 대기하게 됨


쓰레드와 상태제어
쓰레드가 3개가 있다면 JVM은 시간을 잘게 쪼갠 후에 한번은 쓰레드1을, 한번은 쓰레드 2를, 한번은 쓰레드 3을 실행합니다.
 이것에 빠르게 일어나다 보니 쓰레드가 모두 동작하는 것처럼 보이는 것이다.
쓰레드는 실행가능상태인 Runnable과 실행상태인 Running상태로 나뉜다.
실행되는 쓰레드 안에서 Thread.sleep()이나 Object가 가지고 있는 wait()메소드가 호출이 되면 쓰레드는 블록상태가 된다.
Thread.sleep()은 특정시간이 지나면 자신 스스로 블록상태에서 빠져나와 Runnable이나 Running상태가 된다.
Object가 가지고 있는 wait()메소드는 다른 쓰레드가 notify()나 notifyAll()메소드를 호출하기 전에는 블록상태에서 해제되지 않는다.
wait()메소드는 호출이 되면 모니터링 락을 놓게 된다. 그래서 대기중인 다른 메소드가 실행한다.
쓰레드의 run메소드가 종료되면, 쓰레드는 종료된다. 즉 Dead상태가 된다.
Thread의 yeild메소드가 호출되면 해당 쓰레드는 다른 쓰레드에게 자원을 양보하게 된다.
Thread가 가지고 있는 join메소드를 호출하게 되면 해당 쓰레드가 종료될 때까지 대기하게 된다.

